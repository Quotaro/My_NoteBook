# PCネットワーク（WEB）、インフラ関連

## 目次 [Contents]

1. [概要](#ID_1)
1. [インフラの基礎事項](#ID_3)
    1. [システム基盤 [System Infrastructure]](#ID_3-1)
    1. [オンプレミスとクラウド](#ID_3-2)
		1. [オンプレミス [on-premise]](#ID_3-2-1)
		1. [パブリッククラウド [public cloud]](#ID_3-2-2)
		1. [プライベートクラウド [private cloud]](#ID_3-2-3)
		1. [クラウドとオンプレミスの選択](#ID_3-2-4)
	1. [ハードウェアとネットワークの基礎事項](#ID_3-3)
    	1. [ネットワーク機器](#ID_3-3-1)
		1. [OSI 基本参照モデル](#ID_3-3-2)
		1. [ネットワークアドレス](#ID_3-3-3)
		1. [リピーター、ハブ](#ID_3-3-4)
		1. [ブリッジ、レイヤー２スイッチ](#ID_3-3-5)
		1. [ルーター、レイヤー３スイッチ](#ID_3-3-6)
		1. [ファイアウォール](#ID_3-3-7)
1. [Linux OS の基礎事項](#ID_4)
	1. [Linux カーネル](#ID_4-1)
	1. [Linux のファイルシステム](#ID_4-2)
	1. [Linux のディレクトリ構成](#ID_4-3)
	1. [Linux のセキュリティ](#ID_4-4)
1. [ミドルウェアの基礎事項](#ID_5)
	1. [Web サーバーのミドルウェア](#ID_5-1)
	1. [データベースサーバーのミドルウェア](#ID_5-2)
	1. [システム監視ツールのミドルウェア](#ID_5-3)
1. [インフラの構成管理の基礎事項](#ID_6)
	1. xxx
1. [システム基盤の構築、運用の流れ（ウォータフォール開発、アジャイル開発）](#ID_7)
1. [Docker](#ID_8)
	1. xxx

---

<a id="ID_1"></a>

## ■ 概要
![image](https://user-images.githubusercontent.com/25688193/41355764-39f414c0-6f5d-11e8-9991-efdc8657b344.png)<br>

開発したアプリケーションをリリースして、エンドユーザーに使いやすく利用してもらうためには、ハードウェア、OS 等のインフラから構成される **システム基盤 [System Infrastructure]** を構成し、その層の上にアプリケーションの実行環境を構成する必要がある。（上図）<br>
**Docker は、このアプリケーションの実行環境を作成、管理するためのプラットホーム [platform] （土台環境）である。**<br>

<br>

従来のウォータフォールモデルで開発されるシステム開発では、アプリケーションの実行環境の構築は、ハードウェアやネットワークに精通したインフラエンジニアが行い、アプリケーション本体の開発は、アプリケーションエンジニアが行う手法が一般的であった。

しかしながら、クラウド技術の登場により、この従来のシステム開発の手法が大きな変化があった。<br>
具体的には、従来のように自社でデータセンターやマシンルームを保有するような、**オンプレミス [on-premises]** 環境で駆動させていたサーバー群を、クラウド上の**仮想インスタンス [VM : Virtual Machine instance]** に移行し、又、クラウドサービスにあるデータベースやネットワークを利用することで、
アプリケーションの実行環境の構築範囲が極めて小さくなり、短いサイクルで（アプリケーションの）リリースを繰り返すスタイルに変化した。<br>

クラウドを構成する技術の多くは、１台の **物理ホスト** （ネットワーク上のサーバーの一種）上で駆動するシステムとは異なり、**分散環境 [distributed environment]** での駆動が基本となる。<br>
そして、このような分散環境では、従来のインフラエンジニアによる手動の操作ではなく、自動化ツールを使用して**オーケストレーション**（複雑なコンピュータシステムの自動化）を行う。<br>
その為、インフラエンジニアには、インフラ技術に加えてアプリケーションエンジニアと同様に、コードを各スキルが求められるようになった。<br>
一方で、アプリケーションエンジニアも、これまでインフラエンジニアのタスクであった、プロダクション環境（本番環境）への **デプロイ [deploy]**（主にWEBアプリケーションなどのシステム開発においてシステムを利用可能な状態にすること）やテストなども、アプリケーションエンジニア自らが行うことも可能になったため、OS（カーネル）やネットワークのインフラ技術の基礎知識が必要になった。<br>

---

<a id="ID_3"></a>

## ■ インフラの基礎事項

<a id="ID_3-1"></a>

### ◎ システム基盤 [System Infrastructure]
システム基盤とは、アプリケーションを駆動させるために必要なハードウェアや OS、ミドルウェアなどのインフラのことを指す。このシステム基盤は、以下の基本要素から構成される。

![image](https://user-images.githubusercontent.com/25688193/41374963-98d188d8-6f8f-11e8-8b8f-64e6a2c2718c.png)<br>

- ハードウェア<br>
	システム基盤を構成する物理的な要素で、具体的には、サーバー機材本体やデータを保管するためのストレージ、電源装置を指す。<br>
	広義には、これらハードウェア群を設置するデータセンターの設備（建屋、空調、セキュリティ設備、消化設備）を含む。

- ネットワーク<br>
	システムの利用者が遠距離からアクセスできるように、サーバー群を接続する装置。<br>
	具体的には、ルーター、スイッチ、ファイアウォール等のネットワーク機器や、それらを接続するためのケーブル配線など。無線LAN で接続する場合は、アクセスポイントも必要となる。

- OS<br>
	クライアントOSとしては、Windows, masOS等がある。<br>
	サーバーOSとしては、Linux, Unix, Windows Server 等がある。

- ミドルウェア<br>
    ここでいうミドルウェアは、”サーバーOS上で”サーバーが特定の役割を果たすための機能をもつソフトウェアを指す。

<br>

<a id="ID_3-2"></a>

### ◎ オンプレミスとクラウド

<a id="ID_3-2-1"></a>

#### ☆ オンプレミス [on-premise]
自社でデータセンターを保有して、システム構築から運営までを行う形態。<br>
システム基盤の構成要素であるサーバーやネットワーク機材を自らが購入＆調達し、システム要件に応じてインフラを構築し、自社（又は関連子会社）で運用を行う。<br>
又、ハードウェアだけでなく、OSやミドルウェアも全て自社で購入し、ライセンス管理やバージョンアップも自前で行う。<br>

そのため、初期のシステム構築に多額の費用がかかる。<br>
更に、システム稼働後の運用にかかる費用も、”システムの使用量にかかわらず”一定額を負担しなくてはならないのが特徴である。<br>

<a id="ID_3-2-2"></a>

#### ☆　パブリッククラウド [public cloud]
![image](https://user-images.githubusercontent.com/25688193/41385096-7c622ebc-6fb4-11e8-9864-8a90ddd56d2e.png)<br>
インタネットを介して、”不特定多数に提供される”サービス。<br>
自社でデータセンターを保有しなくて済むので、サーバーやネットワークなどのインフラに関する初期費用が不要となる。<br>
提供するサービスにより、**IaaS（イアース、アイアース） / PaaS（パース） / SaaS（サース）** などが存在する。<br>

![image](https://user-images.githubusercontent.com/25688193/41385123-a7c5b402-6fb4-11e8-872b-6fa54237e49a.png)<br>

![image](https://user-images.githubusercontent.com/25688193/41385487-f14e9c5e-6fb6-11e8-8bc6-e53726a39e03.png)<br>

![image](https://user-images.githubusercontent.com/25688193/41385504-0841d976-6fb7-11e8-8025-8592cc21d159.png)<br>

![image](https://user-images.githubusercontent.com/25688193/41385951-b3b6c3f0-6fb9-11e8-997b-b51535142cdd.png)<br>


<a id="ID_3-2-3"></a>

#### ☆ プライベートクラウド [private cloud]
![image](https://user-images.githubusercontent.com/25688193/41386506-989d9ed8-6fbc-11e8-9191-0154b10ece76.png)<br>

特定の企業グループにのみ提供されるクラウドサービス。<br>
利用者が限定されるため、セキュリティが担保しやすく、又、独自の機能やサービスを追加しやすいことが利点として挙げられる。


<a id="ID_3-2-4"></a>

#### ☆ クラウドとオンプレミスの選択

##### クラウドが適しているケース
一般的に、クラウドが向いているシステムには以下のようなケースが挙げられる。<br>

- トラフィックが変動しやすいシステム<br>
	システムには、従業員向けシステム（勤怠管理システム、経理システム等）もあれば、コンシューマ向け（予約システム、オンラインショッピング、オンラインゲームのバックエンド、動画配信等）も存在する。<br>
	前者の従業員向けシステムでは、利用者が限定されるためトラフィックの予想がしやすい。<br>
	一方、コンシューマ向けシステムでは、正確なトラフィックの予想が難しくなる。<br>
	このようなトラフィックの量に応じて、システム基盤のサーバーのスペークやネットワークの帯域を見積もる設計を **”サイジング”** と呼ぶ。サイジングが難しいシステムでは、トラフィックの量に応じてシステムを短期間に容易に増強できるクラウドが向いている。<br>

- 災害対策で日本以外にバックアップを構築したいシステム<br>
- 早くサービスインさせたいシステム<br>

##### オンプレミスが適しているケース

- 高い可用性が求められるシステム<br>
	クラウドでは、システムの可用性（ネットワークの瞬断が許されない等の要件）をクラウドベンダーが保証する。<br>
	従って、クラウドベンダーが保証する以上のシステムの可用性が必要となる場合には、クラウドを本番運用できない。<br>

- 機密性の高いデータを扱うシステム<br>
	データの（ハードウェア上の）保管場所は、クラウドクラウドベンダー側によって決められる。<br>
	従って、物理的な保管場所を明確にするシステムでは、データをパブリッククラウド上に保管することはできないことになる。<br>

- 特殊な要件があるシステム<br>
	特殊な要件、例えば、汎用的でないデバイスや特殊なプラットホーム上でしか動作しないシステム（医療システムなどの専用機器との接続が必要となるシステムなど）を構築、移行する必要がある場合、それらの環境にクラウド側が対応してなければ、クラウドを利用できない。<br>

<br>


<a id="ID_3-3"></a>

### ◎ ハードウェアとネットワークの基礎事項
システム基盤の最下位レイヤーを構成する要素は、ハードウェアとネットワークである。<br>
![image](https://user-images.githubusercontent.com/25688193/41751849-75806898-75fe-11e8-9acb-0aa35793cd1c.png)<br>

ここでは、Docker インフラを構成する際に基本となるハードウェア、ネットワークの基礎事項について見ていく。<br>

<a id="ID_3-3-1"></a>

#### ☆ サーバー機器
一般的なオンプレミスでのシステム基盤は、複数台のサーバー機器から構成される。<br>
クラウドの場合は、仮想マシンのインスタンス（オンプレミスでのサーバー機器に相当）の種類を要件に応じて選定する必要がある。<br>

- CPU<br>
	サーバーで利用される CPU の多くは、コア（CPUの演算回路。コアの数が多いほど同時に演算処理できる数が増加）を複数個もつマルチコアが利用される。<br>
	オンプレミスの場合でもクラウドの場合でも、高性能な CPU や GPU ほど多くの費用がかかる。<br>

- メモリ<br>
	サーバー用のメモリは、省電力でエラー処理が搭載されているものが多く選定させる。<br>
	オンプレミスの場合でもクラウドの場合でも、高性能なメモリほど多くの費用がかかる。<br>

- ストレージ<br>

<br>

<a id="ID_3-3-2"></a>

#### ☆ OSI 基本参照モデル
OSI 基本参照モデルは、ISO によって規定されたコンピューターの通信機能を階層構造に分割した概念モデルであり、通信プロトコルを７つの階層に分けて定義したものである。この階層化により、様々な技術同士の相互接続性を確保することが出来る。<br>
![image](https://user-images.githubusercontent.com/25688193/41754029-87f604c6-760b-11e8-91ad-42ca26fc795a.png)<br>

![image](https://user-images.githubusercontent.com/25688193/41753964-705e7ee2-760b-11e8-94cf-35b3d3beba0e.png)<br>

- 物理層（レイヤー１）<br>
	通信機器の物理的、電気的な特性に関する通信プロトコルを規定する。<br>
	具体的には、ビット列を電気信号に変換するための規定やケーブルやコネクタの形状などを規定する。<br>

- データリンク層（レイヤー２）<br>
	直接的に接続された同じネットワーク内（同一セグメントという）にあるノード間に関しての通信プロトコルを規定する。<br>
	具体的には、どのデバイスにデータ転送（パケット）するのかをネットワークデバイス固有の MAC アドレスで識別した上でデータ転送を行う。<br>
	レイヤー２におけるアドレッシング（デバイスを識別するために ID などの識別子を付随すること）は、
	デバイス固有の MAC アドレスを付随することであるが、より詳細には、宛先 MAC アドレスと送信元 MAC アドレスをフレーム情報として付随する。この際に、宛先 MAC アドレスは、実際に信号を送らないと取得できない。<br>

	尚、MAC アドレスは、実際のデバイスの位置情報を含まないため、インタネット上の場所を特定することはできない。<br>
	従って、後述のネットワーク層で付随される IP アドレスと一緒にしないと、どこにネットワークが存在するのかという情報を得ることはできず、結果として、異なるネットワーク内での通信を構築できない。<br>

- ネットワーク層（レイヤー３）<br>
	異なるネットワーク内にあるノード間に関しての通信プロトコルを規定する。<br>
	具体的には、異なるネットワーク内のデータ転送における経路選択をルーティングというが、このルーティングを IP アドレスをもとに実現する。<br>
	（IP アドレスは、ネットワークデバイスがどこに存在するかの情報をもつため、これを元に異なるネットワーク間の通信を確立できる。）<br>

![image](https://user-images.githubusercontent.com/25688193/41798780-ed455e78-76a9-11e8-9439-694969c69e16.png)<br>

- トランスポート層（レイヤー４）<br>
	ノード間のデータ転送の信頼性（伝送エラー検出等）を確保するための通信プロトコルを規定する。<br>
	より詳細には、確認応答（ACK）、フロー制御（データが溢れないようにバッファに保留する制御）を行い、信頼性の高いデータ転送を実現する。<br>
	
	又、宛先ホストの先にあるホストのどの通信アプリケーション（WEB サーバーを利用した WEB ブラウザやメールサーバーを利用したメールソフトなど）へのデータ転送なのかを判別するために、ヘッダーにポート番号の情報を付随する。<br>
	![image](https://user-images.githubusercontent.com/25688193/41805103-8774186c-76dd-11e8-918f-856ed7f3b470.png)<br>
	このときの通信プロトコルとしては、**TCP** 或いは **UDP** が用いられる。<br>

![image](https://user-images.githubusercontent.com/25688193/41801511-0294ea8a-76b6-11e8-9025-c04286645d7c.png)<br>

- セッション層（レイヤー５）<br>
	通信のコネクション確立のタイミングやデータ転送のタイミングに関する通信プロトコルを規定する。<br>
	尚、ここでいうセッションとは、アプリケーション間での要求（リクエスト）と応答（レスポンス）で構成されるものを表している。<br>

- プレゼンテーション層（レイヤー６）<br>
	データの保存形式や圧縮、文字コードなどのデータの表現形式に関する通信プロトコルを規定する。<br>

- アプリケーション層（レイヤー７）<br>
	Web の HTTP やメール転送の SMTP などのアプリケーション固有の通信プロトコルを規定する。<br>

<br>

OSI 参照モデルでは、各層にそれぞれの通信に関する規定（通信プロトコル）を定めているが、この通信プロトコルに基づいた通信データを作るために、第７層 → 第１層の順で各層の送り主や宛先などのヘッダー情報を入れてカプセル化する。<br>
逆に、送り先のコンピューターは、送られてきたデータを開封し、非カプセル化する。（下図参照）
![image](https://user-images.githubusercontent.com/25688193/41753120-6c16d064-7606-11e8-890a-702cb2c2b042.png)<br>
![image](https://user-images.githubusercontent.com/25688193/41753152-972370a0-7606-11e8-9fcd-edee34af4c39.png)<br>


<a id="ID_3-3-3"></a>

#### ☆ ネットワークアドレス

- MAC アドレス（物理アドレス）<br>
	無線 LAN のチップなどのネットワークデバイスに物理的に割り振られたデバイス固有のアドレス（48 bit）。<br>
	OSI 参照モデルの第２層（データリンク層）で使用される。<br>

	48 bit の内、前半の 24 bit は、部品メーカーを識別する番号で、
	後半の 24 bit は、各部品メーカーが重複しないように割り当てている番号。<br>
	16 進数表記で表示し、先頭から２バイトづつ区切って表記する。<br>

- IP アドレス（論理アドレス）<br>
	インタネットに接続されたコンピューターやネットワークデバイスに割り当られたネットワークに固有の識別番号。<br>
	IP アドレスは、ネットワークデバイスがどこにあるのかという情報を持っており、ネットワークの中でユニークなものでなくてはならないため、アドレスの割り当ては、NIC（ネットワークインフォメーションセンター）という団体によって行われる。<br>
	
	現在広く普及している「IPv4」は、８ビットづつ４つに区切られた３２ビットであり、「192.168.1.1」というように 0 ~ 255 までの１０進数の数字を４つ並べて表記する。<br>


<a id="ID_3-3-4"></a>

#### ☆ リピーター、ハブ
OSI参照モデルの第１層（物理層）に対応するネットワークデバイス。<br>
通信では、実際に回線（銅線、光ファイバー、無線LANなど）を通じてアナログ信号やデジタル信号を送るが、
この信号を送る際に、信号の減衰、ノイズ、衝突などの障害が発生することがある。<br>
これらは、ケーブルを使う際の電気抵抗が直接的な原因で発生するため、
この電気抵抗を減らし、多くの機材を接続することを可能にしたもののが、リピーターやハブというネットワークデバイスである。<br>

- リピーター<br>
	弱まったりノイズがのった信号に対して、増幅や整形をすることで元の同じ形に戻す役割を担う信号増幅器。<br>
	（スイッチやルーターとは異なり、制御は行わず、ただ単に信号を増幅するのみ。）<br>

- ハブ<br>
	リピーターと同様に信号の整形目的での信号の増幅を行い、かつ多くの機材を接続することが出来る装置。<br>


<a id="ID_3-3-5"></a>

#### ☆ ブリッジ、レイヤー２スイッチ
OSI 参照モデルの第２層（データリンク層）に対応するネットワークデバイス。<br>
ネットワーク層では、同じネットワーク内のデバイス間通信を、MACアドレスを付随することで実現するが、イーサネットでは、この際に通信のコリジョンが発生してしまう可能性がある。<br>
この通信のコリジョンを解決するのがブリッジや（レイヤー２）スイッチである。<br>

- ブリッジ<br>
	衝突ドメインのようなネットワークの区切りであるセグメント（言い換えれば、直接的に接続された同じネットワーク）において、**２つのセグメントを繋げるのが、ブリッジの基本的な役割である。**<br>
	又、**MAC アドレスフィルタリング**の役割も持つ。<br>
	**このフィルタリング機能により、衝突ドメインを分割し、結果として、通信トラフィックを低下させることが出来る。**<br>

- （レイヤー２）スイッチ<br>
	基本的には、ブリッジと同様の機能をもつが、異なる点は、マルチポートでスイッチングするという点である。<br>
	詳細には、ブリッジが異なる？ネットワークにフレーム（MACアドレスを付随した通信データ）を送信するかしないかだけを判断するネットワークデバイスであったのに対し、<br>
	**スイッチは、自身が所持しているアドレステーブルを参考にして、各デバイスの送信元と宛先が１対１で接続されている状態にすることが出来る。（マルチポート）**


<a id="ID_3-3-6"></a>

#### ☆ ルーター、レイヤー３スイッチ
OSI 参照モデルの第３層（ネットワーク層）に対応するネットワークデバイス。<br>
２つ以上の異なるネットワーク間の通信を中継し、どのルートを通じてデータ転送を行うかの経路選択（ルーティング）機能を持つ。<br>

より詳細には、ルータ自身の各ポートはそれぞれのネットワークに所属しており、それぞれ固有の MAC アドレスを持っている。そして、ルーティングテーブルと呼ばれる「宛先ネットワーク」、「次の中継ルータ」、「距離」、「送信ポート」という情報をストックしたテーブルを持っており、
このルーティングテーブルを元に目標のノードに対する最適ルートを見つけてルーティングを行う。<br>

ルーティングテーブルを作成する際に、他のネットワークのルートを知っている必要があるが、この方法として、静的ルーティングと動的ルーティングの２種類が存在する。<br>
静的ルーティングは、ネットワーク管理者が手動でルートを入力して経路決定を行う方法である。<br>
一方、動的ルーティングは、ネットワーク上のルーター同士がルート情報を交換し、自動的にルーティングテーブルを作成する。<br>

レイヤー３スイッチは、ルーターとほぼ同じ機能を持つが、ルーティングをハードウェアで実現するため、高速で動作し、接続できるイーサネットのポート数が多いのが異なる点である。<br>


<a id="ID_3-3-7"></a>

#### ☆ ファイアウォール
不要な通信の遮断は、最も有効なセキュリティ対策の１つであるが、**ファイアウォールは、内部ネットワークとその外部との通信を制御することで、内部ネットワークの安全を維持する技術である。**<br>
このファイアウォールには、その遮断方法に応じて幾つかの種類が存在する。<br>

- パケットフィルタ型<br>
	通過する通信データのパケットを、ポート番号や IP アドレスを元に目フィルタリングする方法。<br>
	例えば、「ポート番号 80 (http) と 443 (https) のみ通過してよい」や「安全なセグメント（直接的に接続された同じネットワーク）から届いたパケット以外は全て破棄する」などのルールを決めて、そのルールを元に通信をフィルタリングする。<br>

- アプリケーションゲートウェイ型<br>
	パケットだけではなく、アプリケーションプロトコルのレベルで外部との通信を代替し制御する方法。<br>
	一般的には**プロキシサーバー**と呼ばれている。（プロキシとは、「代理」という意味）

---

<a id="ID_4"></a>

## ■ Linux OS の基礎事項
Linux は、1991 年にフィンランドの Linus Torvalds 氏によって開発された Unix 互換のサーバー OS である。<br>
Linux は、Intel の x86 系マイクロプロセッサを搭載したコンピューターだけでなく、Alpha や SPARC などのプラットホームでも動作する。又、スマートフォンや組み込み機器の OS としても動作している特徴がある。<br>

一般的に、単に Linux と言った場合、以下の２つの意味の何れかで用いられる。<br>
![image](https://user-images.githubusercontent.com/25688193/41804872-49e5a76c-76d9-11e8-9d47-495ca9d0cd2f.png)<br>

- Linux カーネル<br>
	Linux OS のコアとなる部分で、メモリ管理、ファイルシステム、プロセス管理、デバイス制御などのハードウェアやアプリケーションを制御するための基本的機能を実装したソフトウェア。C 言語やアセンブラ言語で書かれている。<br>
	尚、Andriod は、この Linux カーネル上に構成されている。<br>

- Linux ディストリビューション<br>
	Linux カーネルに加えて、各種コマンド、ライブラリ、アプリケーションを含めたパッケージ。（カーネル以外の部分をユーザーランドという）<br>
	通常 Linux は、Linux ディストリビューションという形でパッケージ化されて配布される。<br>
	
	主要な Linux ディストリビューションは、以下の表のようになる。<br>
	![image](https://user-images.githubusercontent.com/25688193/41805109-a89190f6-76dd-11e8-975d-9fe33ef22196.png)<br>


<a id="ID_4-1"></a>

### ◎ Linux カーネル
Linux カーネルは、以下の代表的な基本機能を持つ。<br>

- デバイス管理<br>
	CPU、メモリ、ディスク、I/O デバイス等のハードウェアをデバイスドライバーで制御する。<br>

- プロセス管理<br>
	Linux は命令を実行する際に、そのプログラムのソースファイルに書かれた内容を読み込み、メモリ上に展開する。その上で、このメモリ上のプログラムを実行するが、この実行されたプログラムを **プロセス** と呼ぶ。OS を動作させたり、各種アプリケーションを実行したりすると、このプロセスが複数同時に実行された状態になる。<br>
	Linux カーネルでは、これらのプロセスに PID（プロセスID）という識別子を付けて管理している。<br>
	そして、プロセス実行のために必要となる CPU を効率よく割り当てる処理を行なっている。<br>

- メモリ管理<br>
	プロセスが起動すると、メモリ上にプログラムが展開されるが、同時にプログラム中で使用するデータもメモリ上に展開されるが、Linux カーネルは、プログラム＆データを物理メモリ上に効率よく割り当て＆解放する機能を持つ。<br>
	
	ここで、メモリには容量の物理的な制限があるが、その物理的な容量を超えるようなプログラム＆データを展開する際には、ハードディスクのような補助記憶装置に仮想メモリ領域を確保し、それらを利用する。（この仮想メモリ領域を **スワップ** と呼ぶ。）<br>
	Linux カーネルは、メモリ上に展開された利用頻度の低いデータをスワップに追い出したり（スワップアウト）、逆に、スワップ上のデータをメモリに戻したり（スワップイン）する機能を持つ。<br>

- シェル [Shell]<br>
	Linux カーネルをユーザーが直接操作するためには、シェル [Shell]（殻）を経由して操作出来る。<br>
	シェルは、ユーザーからの命令をコマンドで受け付け、それを Linux カーネルに伝える役割を持つ。<br>
	具体的には、シェルは以下の事項を実行できる。<br>
	- アプリケーションの起動、停止、再起動<br>
	- 環境変数の管理<br>
	- コマンド履歴の管理（コマンドヒストリ）<br>
	- コマンド実行結果の表示やファイル出力<br>

	又、シェルで実行したい命令をまとめてテキストファイルに記述したものを **シェルスクリプト** という。<br>
	シェルスクリプトでは、制御構文が使用できるため、条件分岐や繰り返し処理を行うことが出来る。<br>
	
	尚、Linux で利用できるシェルには、以下の表のように幾つかの種類が存在する。（シェルの種類が異なれば、シェルスクリプトの書き方も異なる。）<br>
	![image](https://user-images.githubusercontent.com/25688193/41806759-aa5fc7ce-76fe-11e8-8cb7-bfac2ccc1bfe.png)<br>


<a id="ID_4-2"></a>

### ◎ Linux のファイルシステム
Linux ファイルシステムは、Linux でハードディスクや USB メモリ、CD / DVD などデバイスにあるデータにアクセスするための仕組みである。<br>

通常、コンピューターがデータを読み書きする際、ドライバー視点では、データをどのデバイスにどうように保存しているのかを意識した処理を行う必要がある。<br>
一方、データを利用するアプリケーション視点では、データがどのデバイスに保存されていようが、同じ方法で透過的にアクセス出来るのことが望ましい。<br>

Linux カーネルでは、**VFS [Virtual File System]（仮想ファイルシステム）** という仕組みを用いて、このデータへの透過アクセスを可能にしている。<br>
この VFS では、各デバイスをファイルとし取り扱っているのが特徴である。<br>

![image](https://user-images.githubusercontent.com/25688193/41815841-5bb123c6-77b1-11e8-9ef9-de24d041101c.png)<br>

Linux で取り扱う主なファイルシステムは、以下の表のようになる。<br>
![image](https://user-images.githubusercontent.com/25688193/41815053-7186a228-779a-11e8-9e6b-c62e4418349d.png)<br>


<a id="ID_4-2-1"></a>

#### ☆ ファイルシステムのマウント
![image](https://user-images.githubusercontent.com/25688193/41815121-eb847a90-779b-11e8-801a-59073b48a692.png)<br>

ディスク上のファイルシステムは、上図のような /（ルートディレクトリ）を頂点とする木構造のどこかのディレクトリに組み込まれている。<br>
逆に言えば、データ（ディスク資源）を利用可能にするためには、この木構造への組み込み（関連付け）作業が必要であり、この作業を **マウント** と呼ぶ。<br>
そして、マウントしたファイルシステムが結合される（組み込まれる）ディレクトリを **マウントポイント** という。（上図では、/home2 ディレクトリがマウントポイント）<br>


<a id="ID_4-3"></a>

### ◎ Linux のディレクトリ構成
Linux は、インストールされると Linux カーネルを含む、各種コマンドや設定ファイルがディレクトリに配置される。<br>
この Linux のディレクトリ一覧は、**FHS [Filesystem Hierarchy Standard]** という規格によって標準化されている。<br>
現在、多くの主要な Linux ディストリビューションが、この FHS 規格を元にディレクトリを構成している。
但し、この FHS 規格に完全準拠しているわけではなく、Linux ディストリビューションによって差異は存在する。<br>

以下の図は、Linux 全体のディレクトリ構成である。<br>
![image](https://user-images.githubusercontent.com/25688193/41815403-ed6cbdbe-77a4-11e8-9a72-9eccaeb1213e.png)<br>

各ディレクトリの概要をもう少し詳しく記載すると、以下の表のようになる。<br>
![image](https://user-images.githubusercontent.com/25688193/41816971-e2c5b546-77cc-11e8-8e9b-65e0024d237b.png)<br>


<a id="ID_4-4"></a>

### ◎ Linux のセキュリティ機能
Linux のもつセキュリティ機能の内、代表的なもののみを取り上げる。<br>

- アカウントによる権限設定<br>

- ネットワークフィルタリングによる機能<br>

- SELinux [Security-Enhanced Linux]<br>

---

<a id="ID_5"></a>

## ■ ミドルウェアの基礎事項
開発したアプリケーションを動作させるためには、ハードウェア・ネットワーク・OS の知識に加えて、ミドルウェアの知識も重要になるケースも存在する。<br>

尚、ここでいうミドルウェアとは、OS と業務処理を行うアプリケーションとの中間に位置するソフトウェアのことを指し、OS のもつ機能を拡張したもの、アプリケーションで使用する共通機能を提供するもの、各種サーバー機能を提供するものなど目的や用途に応じて幅広い種類が利用される。<br>
ここでは、Docker を使う上でポイントとなる代表的なミドルウェアの概要を見ていく。<br>

<a id="ID_5-1"></a>

### ◎ Web サーバーのミドルウェア
Web サーバーとは、クライアント（提供される側）となるブラウザ（Web クライアント）からのリクエスト（HTTP リクエスト）を受けて、コンテンツ（HTML や CSS 等）をレスポンスとして返したり、他のサーバーサイドプログラムを呼び出したりする機能を持つサーバーである。<br>

代表的な Web サーバーには、以下の表のようなものが存在する。<br>
![image](https://user-images.githubusercontent.com/25688193/41825615-3c131b6c-785d-11e8-835c-8caf51b141ad.png)<br>

<a id="ID_5-1-1"></a>

#### ☆ サーバーとクライアント
![image](https://user-images.githubusercontent.com/25688193/41824909-37cab4b6-7853-11e8-9a63-ca19a548b05b.png)<br>

- サーバー：何かを提供する人や物<br>
- クライアント：何かを提供される人や物<br>
- Web サーバー：Web サーバーからコンテンツ（HTML や CSS 等）を閲覧できる状態にしてくれる物。<br>
- Web クライアント：Web ブラウザのこと。<br>

以下、サーバー・クライアント間のやり取り。<br>

1. クライアント側がサーバー側にリクエストを投げる。<br>
2. サーバー側でリクエストを解析、処理してリクエストに対するレスポンスを作る。<br>
3. サーバー側がクライアント側にレスポンスを投げる。<br>


<a id="ID_5-2"></a>

### ◎ データベースサーバーのミドルウェア
データベースサーバーは、システムが生成する様々なデータ（データベース）を管理するためのミドルウェアで、**データベース管理システム DBMS [Database Management System]** が動作しているサーバーである。<br>
データの検索、登録、変更、削除の基本機能に加えて、**トランザクション処理** などを含む。<br>

代表的なデータベースには、以下の表のようなものが存在する。<br>
![image](https://user-images.githubusercontent.com/25688193/41831442-fae181ea-7881-11e8-834b-3e9259bc146c.png)<br>

![image](https://user-images.githubusercontent.com/25688193/41832868-f113e7b4-7888-11e8-9726-afc7c0fd63d5.png)<br>

![image](https://user-images.githubusercontent.com/25688193/41832528-6cbb6c36-7887-11e8-933c-fddb76c620e4.png)<br>

![image](https://user-images.githubusercontent.com/25688193/41832552-82210b30-7887-11e8-859e-82c99f29e764.png)<br>

<a id="ID_5-2-1"></a>

#### ☆ NoSQL
NoSQL はリレーショナルデータベース管理システム（RDBMS）とは異なるデータベース管理システム（DBMS）の総称である。<br>
分散並列処理や柔軟な **スキーマ** 設定（データの構造の記述）などを特徴としている。<br>
主な方式としては、KVS（Key-Value ストア）やドキュメント志向データベース、XML データベースなどが存在する。大量データの蓄積や並列処理を得意とするため、多数のユーザーからのアクセスを処理する必要のあるシステム、
例えば、オンラインシステムなどで広く利用されている。<br>

代表的な NoSQL には、以下の表のようなものが存在する。<br>
![image](https://user-images.githubusercontent.com/25688193/41834885-aa3cce84-7890-11e8-9e79-72bf82efb551.png)<br>


<a id="ID_5-3"></a>

### ◎ システム監視ツールのミドルウェア
システムが本番リリースすると、インフラ運用管理業務が開始されるが、この際に、システムを安定駆動させるために、システム管理者はシステムがどのような状態で駆動しているのかを監視する必要性に迫られる。<br>

一般的なシステムでは、これらの監視をシステム監視ツールによって行う。<br>
このシステム監視ツールは、システムの監視対象のサーバーやデバイスの状態を監視し、予め設定した閾値を超えたときに、決められたアクションを実行するツールである。<br>

代表的なシステム監視ツールには、以下の表のようなものが存在する。<br>
![image](https://user-images.githubusercontent.com/25688193/41845954-2ef0e3d0-78b0-11e8-8a14-e2e4859db1e6.png)<br>


---

<a id="ID_6"></a>

## ■ インフラの構成管理の基礎事項
> 記載中...

---

<a id="ID_7"></a>

## ■ システム基盤の構築、運用の流れ
従来のウォータフォール開発の場合、上流工程から下流工程に順に進めていくことになる。<br>
以下の図は、（インフラ開発における）ウォータフォール開発での手順である。<br>
![image](https://user-images.githubusercontent.com/25688193/41749195-1967c0e6-75f0-11e8-8b3c-3c68949c29c7.png)<br>

一方、アジャイル開発の場合は、迅速かつ適応的に開発を進めていくために、各フェーズでの処理単位を繰り返しながら開発を進めていくことになる。<br>
以下の図は、（インフラ開発における）アジャイル開発での手順である。<br>
![image](https://user-images.githubusercontent.com/25688193/41749981-737b31e0-75f4-11e8-880d-b3497dc83c93.png)<br>

どちらの開発手法の場合でも、（インフラ開発における）ウォータフォール開発やアジャイル開発において、アプリケーション開発とインフラ開発の違いは、**運用フェーズ**の存在となる。<br>
アプリケーション開発においては、プロダクション環境へのシステムリリース後は、バグの修正や追加機能の開発がメインとなり開発要員も減る。
一方でインフラ開発の場合は、リソース監視やセキュリティ対策のためのバージョンアップ、システム障害時対応などの定常業務が残る。<br>
このシステム運用にかかる工程を出来る限り削減し、システムを安定駆動させるために重要なのが**運用設計**となる。具体的には、工程を減らすためにシステム運用で自動化可能な工程を出来る限り自動化するように運用設計することが重要となる。<br>
**Docker は、このシステム構築やシステム運用において、これまで人手で行なっていた作業の多くを自動化し、テスト済みの安全なアプリケーションを継続的に提供することの出来るプラットホームである。**

---

<a id="ID_8"></a>

## ■ Docker
> 記載中...